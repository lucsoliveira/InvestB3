ANOTAÇÕES AO LONGO DO DESENVOLVIMENTO DO PROJETO

--------------------------------------------------------------
                          07/12/2021 
--------------------------------------------------------------

------- Strings

https://docs.python.org/3.10/tutorial/introduction.html

In addition to indexing, slicing is also supported. While indexing is used to obtain individual characters, slicing allows you to obtain substring:

Pegar dois ou mais caracteres de string
>>>
>>> word[0:2]  # characters from position 0 (included) to 2 (excluded)
'Py'
>>> word[2:5]  # characters from position 2 (included) to 5 (excluded)
'tho'

Note that since -0 is the same as 0, negative indices start from -1.

-------------------- Listas
 squares = [1, 4, 9, 16, 25]

square + retangule # para concatenar
cubes.append(216)  # add the cube of 6 ##adicionar um valor ao final


---------------------iF
>>> x = int(input("Please enter an integer: "))
Please enter an integer: 42
>>> if x < 0:
...     x = 0
...     print('Negative changed to zero')

---------------------FOR

https://docs.python.org/3.10/tutorial/controlflow.html

>>> # Measure some strings:
... words = ['cat', 'window', 'defenestrate']
>>> for w in words:
...     print(w, len(w))
...

# Strategy:  Iterate over a copy
for user, status in users.copy().items():
    if status == 'inactive':
        del users[user]
##

lista = ['a', 'b', 'c', 'd']

for i in range(len(lista)):
    print(i, lista[i])

----------------------------- FUNÇÕES
>>> def fib(n):    # write Fibonacci series up to n
...     """Print a Fibonacci series up to n."""
...     a, b = 0, 1
...     while a < n:
...         print(a, end=' ')
...         a, b = b, a+b
...     print()
...
>>> # Now call the function we just defined:
... fib(2000)


----------------------- utilizando o PIP

pip install ipython[notebook]

para executar: ipython notebook

--------------------------------------------------------------
                          08/12/2021 
--------------------------------------------------------------

#No Python tudo é referência. Para evitar alteração numa lista pode-se fazer o seguinte:

def g(x):
	x = x[:] #copia toda a lista
	x.append(51) #adiciona ao final
	return x

x(lista), lista
#printa a lista alterada e, depois, a lista original

#tuplas são sequências imutáveis
tupla = ('A', 'b', 3.13, ['1','2','3'])
#ou pode escrever sem os parenteses
tupla = 'A', 'b', 3.13, ['1','2','3']

##### dicionarios são listas com indices #######
dicionario = {'nome': 'Lucas', 'idade': 23, 'interesses': []}
print(dicionario)

print('\nAcrescentando valor ao dicionário >>>')

dicionario['interesses'].append('Desenvolvimento')
dicionario['interesses'].append('Livros')
dicionario['interesses'].append('Rock')
print(dicionario)

print('\nRemovendo ultimo valor da lista do dicionário >>>')
dicionario['interesses'].pop()
print(dicionario)

print('\nAlterando valor do indice nome >>>')
dicionario['nome'] = 'Lucas de Oliveira'
print(dicionario)


##Orientação a objetos
Dados -> possuem somente valor
Objetos -> possuem valor, identidade e tipo

Variáveis locais definidas no corpo da classe são os atributos da classe.
Se na instância não houver um atributo procurado, a busca se dá na própria classe. É como se a instância só tivesse dados próprios quando estes forem acrescidos após a instânciação.

o "self" equivale ao "this" de outras linguagens

#classe

class Carro:
    portas = 2

    def __init__(self, nome):
        self.nome = nome

# herança
class Ferrari(Carro):
    def __init__(self, modelo):
        super().__init__('Ferrari')
        self.modelo = modelo



